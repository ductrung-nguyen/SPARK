package learnscala1

object test10 {

	def insert(x: Int, xs: List[Int]) : List[Int] = xs match {
  	case List() => x::Nil
  	case y::ys => if (x < y) x::xs else y::insert(x, ys)
  }
  
	def sort(xs:List[Int]) : List[Int] = xs match {
		case List() => List()
		case y::ys => insert(y, sort(ys))
	}
	
	sort(List(4,2,9,6,8))
	
	
	def msort[T](xs: List[T])(implicit ord: Ordering[T] ) : List[T] = xs match {
		case List() => List()
		case x:: Nil => xs
		case x:: xs1 => {
			val n = xs.length/2
			def merge(x1 : List[T], x2: List[T]):List[T] = (x1, x2) match {
				case (x1, Nil) => x1
				case (Nil, x2) => x2
				case (x1head::x1tail, x2head::x2tail) =>
					if (ord.lt(x1head , x2head)) x1head::merge(x1tail, x2)
					else x2head::merge(x1,x2tail)
			}
			val (left,right) = xs.splitAt(n)
			merge(msort(left), msort(right))
		}
	}
	
	val l = List(4, 6, 2,-3 ,5,0,8,9)
	msort(l)(Ordering.Int)
	val fruits = List("Apple", "Orange", "CoCo", "Banana")
	msort(fruits)
	
	l filter (x => x > 0)
	l filterNot (x => x > 0)
	l partition (x => x > 0)
	l takeWhile (x => x > 2)
	l dropWhile (x => x > 2)
	l span (x => x > 2)
	
	def pack[T] (xs : List[T]) : List[List[T]] = xs match {
		case Nil => Nil
		case x :: xs1 => {
			val (l, r) = xs span (y => y == x)
			l :: pack[T](r)
		}
	}
	
	def encode[T] (xs : List[T]) :  List[Pair[T,Int]] = {
		val p = pack(xs)
		p map (x => (x.head, x.length))
		
	}
	
	pack(List("a", "a", "a", "b", "b", "c", "d", "d"))
  encode(List("a", "a", "a", "b", "b", "c", "d", "d"))
  encode(List())
  
  
  def sum(xs : List[Int]) : Int = 0 :: xs reduceLeft (_ + _)
  def sum1(xs : List[Int]) : Int = (xs foldLeft 0) ( _ + _)
  def product(xs : List[Int]) : Int = (xs foldLeft 1) (_ * _)
          
  sum(l)
  sum1(l)
  product(l)
	
  val s = "Hello World"
  s flatMap (c => "." + c)
  s flatMap (c => List('.', c))
  val x = s flatMap (c => Array(1,2))
  x.length
  
  def isPrime(n: Int) = (((2 to n/2) filter ( x => n % x == 0)).length == 0)
  isPrime(1)
  
  
  def findSumPrime(n: Integer) = {
  val result : List[(Int, Int)] = Nil
  
  	(1 until n) flatMap (
  		i => (1 until i) map (
  			j => (i,j)
  		)
  	) filter (pair => isPrime(pair._1 + pair._2))
  	
  }
  def findSumPrime2(n: Integer) =
  	for {
  		i <- 1 until n	 // generator
  		j <- 1 until i	// generator
  		if (isPrime(i + j))
  	} yield (i,j)
  
  findSumPrime(5)
  findSumPrime2(5)
  
  
  def scalaProduct(xs: List[Double], ys: List[Double]) =
  	(for {
  		x <- xs zip ys
  	} yield (x._1 * x._2)) sum
  	
  scalaProduct(List(1,2,3), List(4,5,6))
  
  
  def queen(n : Int) : Set[List[Int]] = {
  	def putQueen(k : Int) : Set[List[Int]] =
  		if (k == 0) Set(List())
  		else
  			for {
  				queens = putQueen(k - 1)
  				col = 0 until n
  				if (isSafe(col, queens))
  			} yield col :: queens
  			
  	def isSafe(col : Int, queens : List[Int]) : Boolean = {
  		val numrow = queens.length
  		val pastSolution = ( numrow -1 to -1 by -1) zip queens
  		pastSolution forall {
  			case (r, c) => c != col && math.abs(col - c) != numrow - r
  		}
  	}
  }
}
	
	