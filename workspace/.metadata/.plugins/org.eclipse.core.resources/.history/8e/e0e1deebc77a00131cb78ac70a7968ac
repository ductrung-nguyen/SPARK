package spark

import collection.immutable.TreeMap
// xName: Name of feature, such as temperature, weather...
// xType: type of feature: 0 (Continuous) or 1 (Category)
abstract class FeatureInfo(val Name: String, val Type: String, val index: Int) {

    protected var sumY : Double = 0
    protected var number_of_record = 0
        
    override def toString() = "Index:" + index + " | Name: " + Name + " | Type: " + Type;
    
    // Process a value of this feature
    def addValue(value: Any, yValue : Double)
    
    // Get all candidates of splitting points
    def getPossibleSplitPoints() : IndexedSeq[Any]
    
    // Return the index of best split point in PossiblePlitPoints
    def getBestSplitPoint() : (Int, Any)
    def getBestSplitPointValue : FeatureValueMap[Any];
    
}

object FeatureInfo {
    def apply(Name: String, Type: String, idx: Int) = {
        Type match {
            case "0" => new NumericalFeature(Name, Type, idx)
            case "1" => new CategoricalFeature(Name, Type, idx)
        }
    }
}

case class NumericalFeature(fName: String, fType: String, fIndex: Int) extends FeatureInfo(fName, fType, fIndex) {
    var min: Double = _
    var max: Double = _
    private var isInit = List(0, 0)
    //private var values = Vector()
    private var values = Vector[FeatureValueMap[Double]]()
    private var BestCutPoint : Int = -1
    
    private val MAX_NUMBER_SPLITPOINT = 10

    override def addValue(value: Any, yValue: Double): Unit = value match {
        case v: Double => {
            insertValue(v, yValue)
            sumY = sumY + yValue
            if (isInit(0) == 0)  { min = v; isInit = isInit.updated(0, 1) }
            else {
                min = if (min > v) v else min
            }

            if (isInit(1) == 0) { max = v ; isInit = isInit.updated(1, 1); }
            else {
                max = if (max < v) v else max
            }
        }

        case s: String => {
            var temp = parseDouble(s)
            temp match {
                case Some(t) => addValue(t, yValue)
            }
        }
    }
    
    private def insertValue(value: Double, yValue: Double) = {

        
        def insertIter(left: Int, right: Int): Unit = {
        
            if (left <= right && right < values.length) {
                
                val mid = (left + right) / 2
                val midElement = values(mid)
                if (value < midElement.fValue) insertIter(left, mid - 1)
                else if (value > midElement.fValue) insertIter(mid + 1, right)
                else values = values.updated(mid, FeatureValueMap(value, midElement.frequency + 1, midElement.sumYValue + yValue))
            } else {
                
                val (leftPart, rightPart) = values.splitAt(left)
                values = (leftPart :+ FeatureValueMap(value, 1, yValue)) ++ rightPart
            }
        }

        insertIter(0, number_of_record - 1)
        number_of_record = number_of_record + 1
    }
    
    override def getPossibleSplitPoints() = {
        if (max == min) Vector() else ((min to max by (max - min)/MAX_NUMBER_SPLITPOINT) map (i => i))
    }
    
    override def getBestSplitPoint() = {
        // Sort all record by the value of this feature in each record
        // we use TreeMap, so every record has been sorted
        var sumRight = sumY; var sumLeft : Double= 0
        var nR = number_of_record; var nL : Int = 0
        var BestTillNow : Double = 0
        var i = 0
        BestCutPoint = -1
        
        values.map(x => {
            sumLeft = sumLeft + x.sumYValue; sumRight = sumRight - x.sumYValue
            nL = nL + x.frequency; nR = nR - x.frequency
            // if (X[x + 1] > X[i]) always be true, because of TreeMap
            val NewSplitValue = sumLeft*sumLeft/nL + sumRight*sumRight/nR
            if (NewSplitValue > BestTillNow) {
                BestTillNow = NewSplitValue
                BestCutPoint = i
            }
            i = i + 1
        })
        (BestCutPoint , values(BestCutPoint))
    }
    
    override def getBestSplitPointValue() = values(BestCutPoint)
    
    private def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }

    override def toString = "Index:" + index + " | Name: " + Name + " | Type: " + Type +
        " | (Min, Max) = (" + min + "," + max + ")" + " Values: " + values;
}

case class CategoricalFeature(fName: String, fType: String, fIndex: Int) extends FeatureInfo(fName, fType, fIndex) {
    
    private var values = Vector[FeatureValueMap[Int]]()
    private var realValues = Map[String, Int]()

    override def addValue(value: Any, yValue : Double) = value match {
        case s: String => { 
        	insertValue(s, yValue)
        	sumY = sumY + yValue
        }
    }
    
    override def getPossibleSplitPoints() = values.map(x => x.fValue)
    
    override def getBestSplitPoint() = {
        // sort by the average of Y associated to each value
        values = values.sortWith((x, y) => (x.sumYValue/x.frequency < y.sumYValue/y.frequency))
        
        var sumRight : Double = sumY; var sumLeft : Double = 0
        var nR = number_of_record; var nL : Int = 0
        var BestTillNow :Double = 0
        val BestPosition : Int = -1
        var i = 0
        values.map ( x => {
            val YB = x.sumYValue
            val NB = x.frequency
            sumLeft = sumLeft + YB ; sumRight = sumRight - YB
            nL = nL + NB; nR = nR - NB
            val NewSplitValue = sumLeft*sumLeft/nL + sumRight*sumRight/nR
            if (NewSplitValue > BestTillNow) {
                BestTillNow = NewSplitValue
                BestPosition = i
            }
            i = i + 1
        })
        
        (1,Nil)
    }
    
    private def insertValue(valueString: String, yValue: Double) = {
    	val value = realValues(valueString)
        def insertIter(left: Int, right: Int): Unit = {
        
            if (left <= right && right < values.length) {
                val mid = (left + right) / 2
                val midElement = values(mid)

                if (value < midElement.fValue) insertIter(left, mid - 1)
                else if (value > midElement.fValue) insertIter(mid + 1, right)
                else values = values.updated(mid, FeatureValueMap(value, midElement.frequency + 1, midElement.sumYValue + yValue))
            } else {
                val (leftPart, rightPart) = values.splitAt(left)
                values = (leftPart :+ FeatureValueMap(value, 1, yValue)) ++ rightPart
                realValues = realValues + (valueString -> values.length)
            }
        }

        insertIter(0, number_of_record - 1)
        number_of_record = number_of_record + 1
    }
    
    override def getBestSplitPointValue() = {
        
        
        values(1)
    }

    override def toString = "Index:" + index + " | Name: " + Name + " | Type: " + Type + " | value=(" +
        (values.map(x => x.fValue) mkString " ; ") + " )";
}

// fValue: value of this feature
// frequency : number of record in which features have this value fvalue
// sumYValue : sum of Y's values of records which features have this fvalue
case class FeatureValueMap[+T] (val fValue : T, var frequency : Int, var sumYValue : Double){
}